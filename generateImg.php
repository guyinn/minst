<?php
/*
 * I was playing around with the MINST and wanted to see if machine can identify the digit images generated by publicly available .ttf fonts
 * Didn't find utils to manipulate or generate MINST data, so wrote few, may save someone's 5-6 hrs of work. Feel free to add/change and share.
 * 
 * Disclaimer:: There is No warranty or claim or anything for any of the code for anything here, use at your own risk ;)
 * 
 * There are three main functions which can be used and are put in as static in MINST class. 
 * 
 */
$cnt = 0;
$outputImagesBin = 1;
$outputImages = 1;
$outImgDir = "./data_images";
$outImgBinDir = "./data_minst";
	
$labelStr = '';
$imageStr = '';

$wt = $ht = 28;
$fontSize = 24;

//1. Parses the given directory recursively and if finds any .ttf file, uses it to generate MINST and/or png files. Switch on $outputImagesBin and $outputImages by assigning 1
MINST::parseAndGenerateMinstNImages('../data/fonts/');

//2. Converts a given minst file to png files in given dir
//MINST::minstToImg('/tmp/tensorflow/mnist/input_data/train-images-idx3-ubyte.gz', '/tmp/tensorflow/mnist/input_data/train-labels-idx1-ubyte.gz', './minst-png', 100);

$imageDataArr = array('/tmp/tensorflow/mnist/input_data/bak-sysfonts/train-images-idx3-ubyte.gz', 
						'/tmp/tensorflow/mnist/input_data/original/train-images-idx3-ubyte.gz');

$labelDataArr = array('/tmp/tensorflow/mnist/input_data/bak-sysfonts/train-labels-idx1-ubyte.gz', 
						'/tmp/tensorflow/mnist/input_data/original/train-labels-idx1-ubyte.gz');

//3. Combines two or more minst files and their corresponding labels
//MINST::combineMinstDataFiles($imageDataArr, $labelDataArr);

class MINST
{
	//Parses the given directory ($path) recursively and uses any .ttf font files found, to generate MINST and/or png files, based on global options $outputImagesBin, $outputImages
	public static function parseAndGenerateMinstNImages($path)
	{
		global $cnt;
		global $outImgDir;
		global $outputImagesBin;
		global $outImgBinDir;
		global $labelStr;
		global $imageStr;
		global $wt, $ht;

		mkdir($outImgDir);
		mkdir($outImgBinDir);

		$dit = new RecursiveDirectoryIterator($path);
		$rit = new RecursiveIteratorIterator($dit);
		$sit = new SortedIterator($rit);

		foreach ($sit as $file) 
		{
			$filename = $file->getPathname();
			if(!endsWith($filename, '.ttf', false) || is_dir($filename)) continue;
			//echo $filename . "\n";
			generateImageData($filename);
		}

		if($outputImagesBin == 1) 
		{
			initLabel($labelInit, $cnt*10);
			$labelStr = $labelInit.$labelStr;
			initImageData($binData, $cnt*10, $wt, $ht);
			$imageStr = $binData.$imageStr;

			$fp = fopen($outImgBinDir.'/train-labels-idx1-ubyte-'.($cnt*10), 'wb');
			fwrite($fp, $labelStr);
			fclose($fp);

			$fp = fopen($outImgBinDir.'/train-images-idx3-ubyte-'.($cnt*10), 'wb');
			fwrite($fp, $imageStr);
			fclose($fp);		
		}
	}
	
	//Converts a given minst data file to png files in given dir
	public static function minstToImg($inputImgFile, $inputLabelFile, $outDir, $maxImgs=10)
	{
		mkdir($outDir);
		gzfile_load_contents($inputImgFile, $contents);

		$imgInfo = unpack("N4", $contents);

		print_r($imgInfo); 

		$data = substr($contents, 16);
		$imgData = unpack("C*", $data);

		//print_r($imgData);

		gzfile_load_contents($inputLabelFile, $contents);
		$labelInfo = unpack("N2", $contents);
		print_r($labelInfo);

		$data = substr ($contents, 8);
		$labelData = unpack("C*", $data);

		//print_r($labelData);
		echo count($imgData) ."------\n";
		createImageFromData($imgInfo, $imgData, $labelData, $outDir, $maxImgs);
	}
	
	//Combines two or more minst files and their corresponding labels
	public static function combineMinstDataFiles(&$imgFileArr, &$labelFileArr)
	{
		global $outImgBinDir;
		$cnt = count($imgFileArr);
		$imgData = '';
		$totalImages = 0;
		$labelData = '';
		$totalLabels = 0;

		$rows = $cols = 28;
		foreach($imgFileArr as $imgFile)
		{
			gzfile_load_contents($imgFile, $contents);

			$imgInfo = unpack("N4", $contents);
			$totalImages += $imgInfo[2];
			//print_r($imgInfo);
			$rows = $imgInfo[3];
			$cols = $imgInfo[4];

			$data = substr($contents, 16);
			$imgData .= $data;
		}

		foreach($labelFileArr as $labelFile)
		{
			gzfile_load_contents($labelFile, $contents);

			$labelInfo = unpack("N2", $contents);
			$totalLabels += $labelInfo[2];
			//print_r($imgInfo);

			$data = substr($contents, 8);
			$labelData .= $data;
		}

		initImageData($binData, $totalImages, $rows, $cols);
		$fp = fopen($outImgBinDir.'/train-images-idx3-ubyte-'.($totalImages), 'wb');
		fwrite($fp, $binData . $imgData);
		fclose($fp);		


		initLabel($binData, $totalLabels);
		$fp = fopen($outImgBinDir.'/train-labels-idx1-ubyte-'.($totalLabels), 'wb');
		fwrite($fp, $binData . $labelData);
		fclose($fp);
	}	
	
}

class SortedIterator extends SplHeap
{
    public function __construct(Iterator $iterator)
    {
        foreach ($iterator as $item) {
            $this->insert($item);
        }
    }
    public function compare($b,$a)
    {
        return strcmp($a->getRealpath(), $b->getRealpath());
    }
}


function generateImageData($fontFile)
{
	global $outputImagesBin;
	global $outputImages;
	global $cnt;
	global $outImgDir;
	global $labelStr;
	global $imageStr;
	global $wt, $ht, $fontSize;
	
	$angle = 0;
	
	$pathParts = pathinfo($fontFile);
	$imgName = cleanImgName($pathParts['filename']);
	

	// Create the image
	$im = imagecreatetruecolor($wt, $ht);

	// Create some colors
	$white = imagecolorallocate($im, 255, 255, 255);
	$black = imagecolorallocate($im, 0, 0, 0);
	
	++$cnt;
	for($i=0; $i<=9; ++$i)
	{
		imagefilledrectangle($im, 0, 0, $wt, $ht, $black);
		echo "$fontFile \n";
		
		$text_height = $ht;
		$text_width = $wt;
		
		$k = 0;
		$fsize = $fontSize;
		while($text_height > ($ht-4) || $text_width > ($wt-4))
		{
			$fsize = $fontSize - $k;
		// Get Bounding Box Size
			$text_box = imagettfbbox($fsize, $angle, $fontFile, $i);
		
			// Get your Text Width and Height
			$text_width = abs($text_box[4]-$text_box[0]);
			$text_height = abs($text_box[7]-$text_box[3]);
			
			echo " $text_width, $text_height \n";
			
			if(++$k >= $fontSize) break;
		}
		
		if($k >= $fontSize) continue;
		// Calculate coordinates of the text
		$x = intval(($wt - $text_width)/2.0);
		$y = round(($text_height  + $ht)/2.0); //- ($text_height/2); $text_height - $text_height/2 + $ht/2;
		
		echo " $x == $y $wt, $ht, $text_width, $text_height \n";
		// Add the text
		imagettftext($im, $fsize, $angle, $x, $y, $white, $fontFile, $i);

		//dumpColors($im, $wt, $ht);	

		if($outputImages == 1)
		{
			imagepng($im, "{$outImgDir}/{$cnt}_{$imgName}_{$i}.png", 9);
		}
		if($outputImagesBin == 1) 
		{
			addLabel($labelStr, $i);
			addImageData($imageStr, $im, $wt, $ht);
		}
	}
	imagedestroy($im);
}



function transformData(&$im, $wt, $ht)
{
	//todo
}


/*
offset] [type]          [value]          [description] 
0000     32 bit integer  0x00000801(2049) magic number (MSB first) 
0004     32 bit integer  60000            number of items 
0008     unsigned byte   ??               label 
0009     unsigned byte   ??               label 
........ 
xxxx     unsigned byte   ??               label
 */
function initLabel(&$binLabel, $totalItems)
{
	$binLabel =  pack('C8',
						(2049 >> 24) & 0xFF,
						(2049 >> 16) & 0xFF,
						(2049 >>  8) & 0xFF,
						(2049 >>  0) & 0xFF,
						($totalItems >> 24) & 0xFF,
						($totalItems >> 16) & 0xFF,
						($totalItems >>  8) & 0xFF,
						($totalItems >>  0) & 0xFF
					  );
	
}

/*
[offset] [type]          [value]          [description] 
0000     32 bit integer  0x00000803(2051) magic number 
0004     32 bit integer  60000            number of images 
0008     32 bit integer  28               number of rows 
0012     32 bit integer  28               number of columns 
0016     unsigned byte   ??               pixel 
0017     unsigned byte   ??               pixel 
........ 
xxxx     unsigned byte   ??               pixel
 */
function initImageData(&$binData, $totalItems, $rows, $columns)
{
	$binData =  pack('C16',
						(2051 >> 24) & 0xFF,
						(2051 >> 16) & 0xFF,
						(2051 >>  8) & 0xFF,
						(2051 >>  0) & 0xFF,
						($totalItems >> 24) & 0xFF,
						($totalItems >> 16) & 0xFF,
						($totalItems >>  8) & 0xFF,
						($totalItems >>  0) & 0xFF,
						($rows >> 24) & 0xFF,
						($rows >> 16) & 0xFF,
						($rows >>  8) & 0xFF,
						($rows >>  0) & 0xFF,
						($columns >> 24) & 0xFF,
						($columns >> 16) & 0xFF,
						($columns >>  8) & 0xFF,
						($columns >>  0) & 0xFF
					  );
}


function addLabel(&$binLabel, $val)
{
	$binLabel .= pack('C', $val);
}

function addImageData(&$binStr, &$im, $wt, $ht)
{
	for ($i=0; $i<$ht; ++$i)
	{
		for($j=0; $j<$wt; ++$j)
		{
			$rgb = imagecolorat($im, $j, $i);
			$r = (($rgb >> 16) & 0xFF) ;
			$g = (($rgb >> 8) & 0xFF) ;
			$b = ($rgb & 0xFF) ; 
			
			$val = ($r + $g + $b) / 3.0;
			
			$binStr .= pack('C', $val);
		}
	}
	
}


//helps in debug
function dumpColors($im, $wt, $ht)
{
	for ($i=0; $i<$ht; ++$i)
	{
		for($j=0; $j<$wt; ++$j)
		{
			$rgb = imagecolorat($im, $j, $i);
			$r = (($rgb >> 16) & 0xFF) ;
			$g = (($rgb >> 8) & 0xFF) ;
			$b = ($rgb & 0xFF) ; 
			
			$val = ($r + $g + $b) / 3.0;
			
			echo "$val <br>";
		}
	}
}


function startsWith($haystack, $needle, $case = true)
{
  if($case)
  {
    return (strcmp(substr($haystack, 0, strlen($needle)), $needle) === 0);
  }
  return (strcasecmp(substr($haystack, 0, strlen($needle)), $needle) === 0);
}

function endsWith($haystack, $needle, $case = true)
{
  if($case)
  {
    return (strcmp(substr($haystack, strlen($haystack) - strlen($needle)), $needle) === 0);
  }
  return (strcasecmp(substr($haystack, strlen($haystack) - strlen($needle)), $needle) === 0);
}

function cleanImgName($str)
{
  return preg_replace("/[^A-Za-z0-9_-]+/", '', $str);
}


function gzfile_load_contents($filename, &$data) { 
    $file = gzopen($filename, 'rb'); 
    if ($file) { 
        $data = ''; 
        while (!gzeof($file)) { 
            $data .= gzread($file, 1024); 
        } 
        gzclose($file); 
    } 
} 

function createImageFromData(&$imgInfo, &$imgData, &$labelData, $outDir, $maxImgs)
{
	$wt = $imgInfo[3];
	$ht = $imgInfo[4];
	
	$cnt = 0;
	// Create the image
	$im = imagecreatetruecolor($wt, $ht);

	// Create some colors
	$white = imagecolorallocate($im, 255, 255, 255);
	$black = imagecolorallocate($im, 0, 0, 0);
	
	$totalPixelsPerImg = $wt * $ht;
	
	$maxImgs = $maxImgs > $imgInfo[2] ? $imgInfo[2] : $maxImgs;
	
	//print_r($labelData);
	echo "$wt, $ht, $maxImgs ";
	
	for($imgCnt=0; $imgCnt<$maxImgs; ++$imgCnt) //0 to total Images
	{
		imagefilledrectangle($im, 0, 0, $wt, $ht, $black);
		for($i=0; $i<$wt; ++$i)
		{
			for($j=0; $j<$ht; ++$j)
			{
				$pixelIndex = $imgCnt*$totalPixelsPerImg + $i*$wt + $j + 1;
				$color = imagecolorallocate($im, $imgData[$pixelIndex], $imgData[$pixelIndex], $imgData[$pixelIndex]);

				// Set the backgrund to be blue
				imagesetpixel($im, $j, $i, $color);
			}
		}
		$label = $labelData[$imgCnt + 1];
		imagepng($im, "{$outDir}/{$imgCnt}_{$label}.png", 9);
	}
	imagedestroy($im);
}


?>